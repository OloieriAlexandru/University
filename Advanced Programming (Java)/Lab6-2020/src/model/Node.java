package model;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class Node implements Serializable {
    private int index;
    private Shape shape;
    private List<Edge> adjacencyList = null;

    public Node(int index, Shape shape) {
        this.index = index;
        this.shape = shape;
        this.adjacencyList = new ArrayList<>();
    }

    /**
     * Draws this node on a buffered image
     */
    public void paint(Graphics2D graphics2D, BufferedImage image) {
        for (Edge edge : adjacencyList) {
            edge.paint(graphics2D, image, this);
        }

        shape.draw(graphics2D, image);
    }

    /**
     * Adds a node to the adjacency list of the current node
     */
    public void addAdjacentNode(Node node, Color color) {
        adjacencyList.add(new Edge(node, color));
    }

    /**
     * Removes a node from the adjacency list of the current node
     */
    public void removeAdjacentNode(Node node) {
        int index = -1;
        for (int i = 0; i < adjacencyList.size(); ++i) {
            if (adjacencyList.get(i).getNode().equals(node)) {
                index = i;
                break;
            }
        }
        if (index == -1) {
            return;
        }
        adjacencyList.remove(index);
    }

    /**
     * Computes the total forces which are applied to the current point
     * This function is called for each point during a Force Drawing Graph Algorithm iteration
     */
    public Force computeTotalForce(List<Node> nodes) {
        Force globalForce = new Force();

        for (Node node : nodes) {
            if (node.equals(this) || adjacentTo(node)) {
                continue;
            }
            Force force = getRepulsiveForceNode(node);
            globalForce.add(force);
        }

        for (Edge edge : adjacencyList) {
            globalForce.add(getAttractiveForce(edge));
        }

        double eta = 0.99;
        double alpha = 1.0;
        double deltaT = 0.01;

        double nvx = (shape.getVx() + alpha * globalForce.getFx() * deltaT) * eta;
        double nvy = (shape.getVy() + alpha * globalForce.getFy() * deltaT) * eta;

        shape.setVx(nvx);
        shape.setVy(nvy);

        return new Force(nvx, nvy);
    }

    /**
     * Updates the node position, based on the value of the force
     */
    public void updatePosition(Force force, double percent) {
        double actX = shape.getX() + shape.getVx() * percent;
        double actY = shape.getY() + shape.getVy() * percent;

        shape.setX(actX);
        shape.setY(actY);
    }

    /**
     * Computes the force generated by a non-adjacent node
     */
    public Force getRepulsiveForceNode(Node node) {
        double dx = node.getX() - getX();
        double dy = node.getY() - getY();
        double ds2 = dx * dx + dy * dy;
        double ds = Math.sqrt(ds2);
        double ds3 = ds2 * ds;
        double mul;
        double beta = 0.001;
        if (ds3 < 0.000001) {
            mul = 0.0;
        } else {
            mul = beta / (ds3);
        }
        return new Force(-mul * dx, -mul * dy);
    }

    /**
     * Computes the force generated by an adjacent node
     */
    private Force getAttractiveForce(Edge edge) {
        double dx = edge.getNode().getX() - getX();
        double dy = edge.getNode().getY() - getY();
        double ds = Math.sqrt(dx * dx + dy * dy);
        double dl = ds - 0.3;
        double k = 1.0;
        double mul = k * dl / ds;
        return new Force(mul * dx, mul * dy);
    }

    /**
     * Removes this node from all the adjacency lists
     */
    public void removeFromAdjacencyLists() {
        for (Edge edge : adjacencyList) {
            edge.getNode().removeAdjacentNode(this);
        }
    }

    public boolean intersects(double x, double y, int size) {
        return shape.intersects(x, y, size);
    }

    public boolean isInside(double x, double y) {
        return shape.isInside(x, y);
    }

    /**
     * Checks if this node is adjacent to another node (the second node is identified by index)
     */
    public boolean isAdjacentTo(int index) {
        for (Edge edge : adjacencyList) {
            if (edge.getNodeIndex() == index) {
                return true;
            }
        }
        return false;
    }

    public int getIndex() {
        return index;
    }

    public double getX() {
        return shape.getX();
    }

    public double getY() {
        return shape.getY();
    }

    public List<Edge> getAdjacencyList() {
        return adjacencyList;
    }

    public void decreaseIndex() {
        --index;
    }

    public void resetPos() {
        shape.resetPosition();
    }

    public void computePos() {
        shape.computePosition();
    }

    /**
     * Checks if this node is adjacent to another node (the second node is identified by the value of the object)
     */
    private boolean adjacentTo(Node node) {
        for (Edge edge : adjacencyList) {
            if (edge.getNode().equals(node)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Node node = (Node) o;
        return Objects.equals(shape, node.shape);
    }

    @Override
    public int hashCode() {
        return Objects.hash(shape);
    }
}
