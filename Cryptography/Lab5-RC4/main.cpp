#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <chrono>
#include <iomanip>

#include "RC4.h"

std::vector<std::string>commands;

void initCommandLine() {
	commands.push_back("encrypt");
	commands.push_back("decrypt");
	commands.push_back("generate");
	commands.push_back("single-byte-bias-1");
	commands.push_back("single-byte-bias-2");
	commands.push_back("list");
	commands.push_back("quit");
}

void printCommands() {
	for (unsigned i = 0; i < commands.size(); ++i) {
		std::cout << i + 1 << ". " << commands[i] << '\n';
	}
}

bool stringIsUInt(const std::string& str) {
	if (str.size() > 9) {
		return false;
	}
	for (unsigned i = 0; i < str.size(); ++i) {
		if (!(str[i] >= '0' && str[i] <= '9')) {
			return false;
		}
	}
	return true;
}

int getUIntFromString(const std::string& str) {
	int res = 0;
	for (unsigned i = 0; i < str.size(); ++i) {
		res = res * 10 + (str[i] - '0');
	}
	return res;
}

void trim(std::string& str) {
	reverse(str.begin(), str.end());
	while (str.size() && str.back() == ' ') {
		str.pop_back();
	}
	reverse(str.begin(), str.end());
	while (str.size() && str.back() == ' ') {
		str.pop_back();
	}
}

int parseLine(std::string& line) {
	trim(line);
	if (stringIsUInt(line)) {
		int option = getUIntFromString(line);
		--option;
		if (!(option >= 0 && option < commands.size())) {
			return -1;
		}
		return option;
	}
	for (unsigned i = 0; i < commands.size(); ++i) {
		if (commands[i] == line) {
			return i;
		}
	}
	return -1;
}

void commandEncrypt() {
	RC4 rc4;
	rc4.readKey();

	std::cout << "Enter the text you want to encrypt:\n";
	std::string line;
	std::getline(std::cin, line);
	if (!line.size()) {
		std::getline(std::cin, line);
	}

	std::vector<unsigned char> byteArr;
	for (auto x : line) {
		byteArr.push_back((int)x);
	}

	std::cout << "Encrypted byte array:\n";
	rc4.encrypt(byteArr);
}

unsigned char readInt(const std::string& str, int pos) {
	unsigned char res = 0;
	while (pos < str.size() && str[pos] >= '0' && str[pos] <= '9') {
		res = res * 10 + (str[pos] - '0');
		++pos;
	}
	return res;
}

void commandDecrypt() {
	RC4 rc4;
	rc4.readKey();

	std::cout << "Enter the text you want to decrypt:\n";
	std::string line;
	std::getline(std::cin, line);
	if (!line.size()) {
		std::getline(std::cin, line);
	}

	std::vector<unsigned char> byteArr;
	for (int i = 0; i < line.size(); ++i) {
		if (!(line[i] >= '0' && line[i] <= '9')) {
			continue;
		}
		if (i == 0 || (line[i - 1] == ' ')) {
			byteArr.push_back(readInt(line, i));
		}
	}

	std::cout << "Decrypted string:\n";
	rc4.decrypt(byteArr);
}

void commandGenerate() {
	RC4 rc4;
	rc4.readKey();

	std::cout << "Enter the number of bytes you want to generate:\n";
	int numberOfBytes;
	std::cin >> numberOfBytes;

	std::vector<unsigned char> bytes = rc4.generate(numberOfBytes);
	
	std::cout << "The generated bytes:\n";
	for (auto x : bytes) {
		std::cout << (int)x << ' ';
	}
	std::cout << '\n';
}

void commandSingleByteBiasedExperiment_1() {
	std::cout << "Enter the number of times you want to generate bytes:\n";
	int numberOfTimes;
	std::cin >> numberOfTimes;

	std::vector<long long> generatedByteTimes(256);

	for (int i = 1; i <= numberOfTimes; ++i) {
		RC4 rc4;
		rc4.generateKey();
		std::vector<unsigned char> bytes = rc4.generate(2);
		++generatedByteTimes[bytes[1]];
	}

	long long avg = 0;
	for (int i = 0; i < 256; ++i) {
		if (i < 10) {
			std::cout << "  ";
		}
		else if (i < 100) {
			std::cout << " ";
		}
		std::cout << i << ": " << generatedByteTimes[i] << '\n';
		if (i) {
			avg += generatedByteTimes[i];
		}
	}
	avg /= 255;

	double percent_0 = 1.0 * generatedByteTimes[0] / numberOfTimes;
	double percent_others = 1.0 * avg / numberOfTimes;

	std::cout << std::setprecision(8) << std::fixed;
	std::cout << "The probability that Z2 is 0: " << percent_0 << '\n';
	std::cout << "The average of probabilities of the other bytes: " << percent_others << '\n';
	std::cout << "128 * prob_0 = " << 128.0 * percent_0 << '\n';
}

void commandSingleByteBiasedExperiment_2() {
	std::cout << "Enter the number of times you want to generate bytes:\n";
	int numberOfTimes;
	std::cin >> numberOfTimes;

	std::vector<long long> generatedByteTimes(256);

	for (int i = 1; i <= numberOfTimes; ++i) {
		RC4 rc4;
		rc4.generateKey();
		if (i % 1000000 == 0) {
			std::cout << (i / 1000000);
		}
		std::vector<unsigned char> bytes = rc4.generate(256);
		for (int j = 0; j < bytes.size(); ++j) {
			if (bytes[j] == 0) {
				++generatedByteTimes[j];
			}
		}
	}

	for (int i = 0; i < 256; ++i) {
		if (i < 10) {
			std::cout << "  ";
		} else if (i < 100) {
			std::cout << " ";
		}
		double p = (generatedByteTimes[i] * 1.0) / numberOfTimes;
		p -= (1.0 / 256.0);
		p *= 256.0 * 256.0;
		std::cout << std::setprecision(6) << std::fixed << p << '\n';
	}
}

int main() {
	srand(time(NULL));

	initCommandLine();
	printCommands();

	bool running = true;
	while (running) {
		std::string line;
		std::getline(std::cin, line);
		if (line.size() == 0) {
			continue;
		}
		int command = parseLine(line);
		switch (command) {
		case 0:
			commandEncrypt();
			break;
		case 1:
			commandDecrypt();
			break;
		case 2:
			commandGenerate();
			break;
		case 3:
			commandSingleByteBiasedExperiment_1();
			break;
		case 4:
			commandSingleByteBiasedExperiment_2();
			break;
		case 5:
			printCommands();
			break;
		case 6:
			running = false;
			break;
		default:
			std::cout << "Invalid command!\n";
			break;
		}
	}
	return 0;
}